# 4.2 shell基础

## 4.2.1 通配符

文件的扩展称为通配，通配定义了一整套使用特殊字符的规则。
常用的通配符如下
|符号|含义|
|:---:|:---:|
|*|匹配任何字符的0次或多次出现|
|？|匹配任意单个字符|
|[ ]|匹配该字符组所限定的任何一个字符|
|[^]或[!]|匹配不在该字符组中的任何一个字符|
|{string1,string2,.......}|匹配其中一个指定的字符串|

1. \* (星号)
   \* 匹配任意字符的0次或多次出现。例如，用户输入ls -l file\*，shell在运行命令之前，会以合适的文件名进行替换，找出当前目录中以 file 开头的文件名并执行，如果通配符不能匹配任何文件，shell将会显示一个报错信息。
2. ?(问号)
   ? 匹配任意单个字符（除/之外）。
   例如：
   d? 表示以"d"开头的两个字符的文件名;
   ?? 表示任何两个字符的文件名;
   ?*y 表示至少两个字符，并且以"y"结束的文件名。
3. \[ ] (一对方括号)
   [ ]将一组字符列表括起来，其作用是匹配该字符组所限定的任意一个字符。
   例如，space.[co]匹配space.c或者space.o，[Hh]*匹配以"H"或"h"开头的文件名。[ ]中无论有几个字符，都只代表一个字符，在[ ]中，可以使用 " - " 指定字符的范围，例如[0-9]匹配任何0至9的数字。
4. [ ^ ] (音调符号)或 [ ! ] (惊叹号)
   为了匹配不在列表中的字符，需要在列表的开头加一个＾或者！，代表反向选择。例如，[^Hh]\* 和 [!Hh]\* 匹配以非"H"或"h"开头的文件名。
5. { } (大括号)
   {string1,string2,string3,......}匹配string1或string2（或更多）中的一个字符串，｛｝告诉shell依次使用每种string形成一个单独的文件名进行匹配，大括号扩展只适用于bash，tcsh和C shell，不适用于Korn shell和FreeBSD shell。例如，用户希望查看目录/home/student,/home/csl,/home/re中所有文件的名称

    ```shell
    ls /home/student /home/csl /home/re
    ```

    使用｛｝(大括号)命令就比较简单：

    ```shell
    ls /home/{studet,csl,re}
    ```

    注意：{string1,string2,string3,......}中的逗号前面和后面都不能有空格。

## 4.2.2 引号

shell中的引用字符有3种：单引号，双引号和倒引号。

关于转义字符" \ "：

```shell
echo It is warm;come over and visit 
```

这条命令中" ; "是特殊字符，是命令执行操作符，所以命令不会被正确执行，使用转义字符" \\ "将" ; "转为普通字符后，命令就可以正确执行了。

```shell
echo It is warm\;come over and visit 
```

如果只是用来转义特殊字符，那么使用反斜线就足够了，但对于下例：

```shell
echo It is warm (and sunny); come over & visit
```

此例中出现了多个特殊字符"("  ")" ";"和"&"，为了使该命令正确运行，需要将这四个特殊字符转义。

```shell
echo It is warm \(and sunny\)\; come over \& visit
```

该命令虽然有效运行，可以正常工作，但是不容易阅读。作为另一种选择方案，引号就可以有效地解决上述问题。

1. 单引号
   上述命令可以方便地修改为：

    ```shell
    echo 'It is warm (and sunny); come over & visit'
    ```

    被单引号括起来的所有字符都是普通字符，就算特殊字符也不再有特殊含义。在某些时候，会希望使用个别特殊字符，如 $ 来引用变量的值，例如：

    ```shell
    echo 'the dir is <$HOME>; the userid is <$USER>'
    ```

    这时命令就不能正常工作，在不使用转义字符" \\ "时，双引号可以很好地解决这个问题。
2. 双引号
    由双引号括起来的字符（除 \$、倒引号和转义字符" \\ "外）均作为普通字符。"\$" "\\"和倒引号是拥有特殊含义的，"\$"代表引用变量的值，而倒引号代表引用命令。在上例中，采用双引号可以使"$"保留特殊含义，而其他特殊字符均作为普通字符。

    ```shell
    echo "the dir is <$HOME>; the userid is <$USER>"
    ```

3. 倒引号
   由倒引号括起来的字符串被shell解释为命令行，shell会先执行该命令，并以它的标准输出结果取代整个倒引号部分。倒引号的作用和 \$(命令) 是一样的。

    ```shell
    today = 'date'
    echo Today is $today
    ```

## 4.2.3 输入/输出重定向符

shell重定向分为输入重定向和输出重定向。
登录时，shell会自动地将程序的输入源设置为键盘，称为标准输入；设置程序运行的正确结果输出到显示器，称为标准输出；将程序运行中的出错信息输出位置也设置为显示器，称为标准错误。标准输入，标准输出和标准错误都以文件的方式存在，通常缩写为stdin、stdout和stderr。
每次输入命令都可以告诉shell在此命令执行期间重新设置输入和输出的方向。如执行sort命令时，输出结果不需要显示在屏幕上，而是要保存到一个名为name的文件中。在执行该命令时，使用输出重定向符">",指出输出要写入的目标就可以了，如下：

```shell
sort file > name
```

常见的输入/输出重定向符
|类型|符号|作用|
|:---:|:---:|:---:|
|标准输入重定向|command <file |将文件作为命令的输入|
|标准输入重定向|command <<分界符|从标准输入中读入，直到遇见分界符才停止|
|标准错误重定向|command 2>file|以覆盖的方式，把command的错误信息输出到file文件中|
|标准错误重定向|command 2>>file|以追加的方式，把command的错误信息输出到file文件中|
|标准输出重定向|command >file|以覆盖的方式，把command的正确输出结果输出到file文件中|
|标准输出重定向|command >>file|以追加的方式，把command的正确输出结果输出到file文件中|

1. 输入重定向符 <
   输入重定向符" < "的作用是把命令（或可执行文件）的标准输入重新定向到指定文件，如前例中的 bash < sh01 就是使用输入重定向。

2. 输入重定向符 <<
   与输出重定向不同，<< 不代表追加的意思。输入重定向符号<<的作用是使用特定的分界符作为命令输入的结束标志，而不是用默认的Ctrl+D。

3. 输出重定向符 >
   输出重定向符" > "的作用是把命令（或可执行文件）的标准输出重新定向到指定文件（或其它输出目标）。这样，该命令的结果就不在屏幕上显示，而是写入指定文件中（或其他输出目标）。例如:

   ```shell
   cat file1 file2 > file3
   ```

   以这种方式将命令输出写到文件中时，这个文件可以存在，也可以不存在。如果不存在，那么shell将会自动创建此文件，如果存在，那么它的内容将会被覆盖，原文件内容丢失。

4. 输出追加重定向符
   输出追加重定向符">>"的作用是把命令（或可执行文件）的标准输出附加到指定文件（或其他输出目标）的后面，该文件原有内容不被破坏。

   ```shell
   cat file1 file2 >>file3
   ```

   file1和file2的内容连接起来附加到file3的结尾处，利用cat显示file3的全部内容，包括原有的内容和新添加内容

5. 文件描述符
   输出重定向的完整写法其实是fd>file或者fd>>file,其中fd表示文件描述符，如果不写，默认为1，也就是标准输出文件。当文件描述符为1时，一般都省略不写，即command >file等价于command 1>file。
   在每个进程中，为了表示和区分已经打开的文件，Linux会给每个文件分配一个ID，这个ID就是一个整数，被称为文件描述符（File Descriptor）。Linux程序在执行任何形式的I/O操作时，都是在读或者写一个文件描述符。在进程创建时，系统为每个进程自动打开三个标准文件（即标准输入stdin，标准输出stdout和错误输出stderr），它们都是默认打开的，其文件描述符分别为0、1、2.在重定向的过程中，0、1、2这三个文件描述符可以直接使用。

## 4.2.4 命令执行操作符

多条命令可以在一行中出现，用命令执行操作符链接，则将按如下规则执行命令。

1. 顺序执行
   如果使用" ; "连接多条命令，那么这些命令会依次执行，各命令之间没有任何逻辑关系，也就是说，无论哪条命令报错了，后面的命令仍会依次执行。例如：

   ```shell
   ls; date; cd /usr; pwd
   ```

   它与写成多行的形式是等价的。

2. 逻辑与
   如果使用"&&"连接多条命令，那么这些命令之间就有逻辑关系了。只有第一条命令正确执行了，"&&"；连接的第二条命令才会执行。例如：

   ```shell
   cp /root/test /tmp/test
   rm /root/test
   ```

   使用&&操作符后，可以写成

   ```shell
   cp /root/test /tmp/test && rm /root/test
   ```

3. 逻辑或
   使用"||"连接多条命令，则只有前一条命令执行错误，后一条命令才能执行。

   ```shell
   ls /root/test || mkdir /root/test
   ```

   如果/root/test不存在，就创建改目录。
   操作符"&&"和"||"优先级相同。如果要判断每条命令是否正确执行，就可以这样来做。

   ```shell
   ls /root/test && echo "yes" || echo "no"
   ```

## 4.2.5 小括号和大括号

关于父shell和子shell：
当用户登陆后启动shell时，这个shell是交互式的。当以这种方式工作时，shell是用户界面，当它执行完一条命令后，接着显示另一个提示符，始终在前台等待用户交互。还有一种shell是非交互的，当在交互shell中运行一个外部命令或者执行一个脚本时，交互shell会创建一个子shell，这个shell在不需要输入的情况下，一次性处理所有的命令，运行结束后子shell进程结束。

小括号( )和大括号{ }都可以将若干命令括起来，组合在一起，在逻辑上被视为一条命令。例如：

```shell
{ echo "User Report for 'date'"; who;} |pr
```

使用{ }时在格式上应注意，左括号 { 后面应有一个空格，右括号 } 之前要有一个分号" ; ".大括号也可以包括若干单独占一行的命令，例如：

```shell
{ echo "User Report for 'date'"
echo
echo "there are 'who | wc -l 'users logged in"
echo
who |sort ;} |pr
```

大括号中的命令表必须用分号或者换行符终止。
成组命令也可以用小括号括起来，例如：

```shell
(name=liming, echo $name)
```

在成组命令用小括号括起来时，左括号后不必有空格，右括号之前也不需要加上分号。
在用于成组命令的执行时，小括号的大括号的主要区别在于：小括号执行成组命令时，需要重新开启一个子 shell来执行，而大括号在执行成组命令时，是在当前shell中执行。

## 4.2.6 管道符、后台命令符和注释符

在shell中，管道符由竖杠" | "代表。管道符用来连接多条命令，如“命令1 | 命令2”。每个命令执行时都有一个独立的进程，前一个命令的输出是，后一个命令的输入。此处需注意，命令1必须有正确输出，而命令2必须可以处理命令1的输出结果，而且命令2只能处理命令1的正确输出，而不能处理错误输出。

后台命令符"&"使得在shell中实现躲到进程运行成为可能：一个进程在前台运行，其他进程在后台运行。前台程序在执行过程中，用户和进程可以发生交互————响应用户输入数据，进程处理数据名输出结果，这种方式就是前台方式。后台进程在运行过程中，与用户无交互，即不响应用户的输入和终端控制信号。
适合在后台运行的命令是一些执行时间较长且无交互的命令，如编译程序、费事的排序程序及一些shell脚本。在后台运行作业时要注意，在后台运行的命令一样会将结果输出到屏幕上，干扰用户的工作。如果放在后台运行的作业会产生大量的输出，最好把它的输出重定向道某个文件中，如：

```shell
gcc m1.c > out.file 2>&1 &
```

shell脚本以"#"开头的正文行表示单行注释。在脚本中，第一行以"#!"开头，"#!"后面跟的是解释该脚本的shell的绝对路径，意味着首先按绝对路径找到shell程序，启动shell程序，以该shell程序解释脚本。单纯的"#"表示单行注释，从"#"到行尾，shell会自动忽略不执行。